{"ast":null,"code":"import { hyphenateProperty } from './utils/hyphenateProperty.esm.js';\nimport { normalizeNestedProperty } from './utils/normalizeNestedProperty.esm.js';\nimport { compileCSSRules } from './compileCSSRules.esm.js';\nconst PSEUDO_SELECTOR_REGEX = /,( *[^ &])/g;\n\n/**\n * Normalizes pseudo selectors to always contain &, requires to work properly with comma-separated selectors.\n *\n * @example\n *   \":hover\" => \"&:hover\"\n *   \" :hover\" => \"& :hover\"\n *   \":hover,:focus\" => \"&:hover,&:focus\"\n *   \" :hover, :focus\" => \"& :hover,& :focus\"\n */\nfunction normalizePseudoSelector(pseudoSelector) {\n  return '&' + normalizeNestedProperty(\n  // Regex there replaces a comma, spaces and an ampersand if it's present with comma and an ampersand.\n  // This allows to normalize input, see examples in JSDoc.\n  pseudoSelector.replace(PSEUDO_SELECTOR_REGEX, ',&$1'));\n}\nfunction createCSSRule(classNameSelector, cssDeclaration, pseudos) {\n  let cssRule = cssDeclaration;\n  if (pseudos.length > 0) {\n    cssRule = pseudos.reduceRight((acc, selector) => {\n      return `${normalizePseudoSelector(selector)} { ${acc} }`;\n    }, cssDeclaration);\n  }\n  return `${classNameSelector}{${cssRule}}`;\n}\nfunction compileAtomicCSSRule(options) {\n  const {\n    className,\n    media,\n    layer,\n    selectors,\n    support,\n    property,\n    rtlClassName,\n    rtlProperty,\n    rtlValue,\n    value,\n    container\n  } = options;\n  const classNameSelector = `.${className}`;\n  const cssDeclaration = Array.isArray(value) ? `${value.map(v => `${hyphenateProperty(property)}: ${v}`).join(';')};` : `${hyphenateProperty(property)}: ${value};`;\n  let cssRule = createCSSRule(classNameSelector, cssDeclaration, selectors);\n  if (rtlProperty && rtlClassName) {\n    const rtlClassNameSelector = `.${rtlClassName}`;\n    const rtlCSSDeclaration = Array.isArray(rtlValue) ? `${rtlValue.map(v => `${hyphenateProperty(rtlProperty)}: ${v}`).join(';')};` : `${hyphenateProperty(rtlProperty)}: ${rtlValue};`;\n    cssRule += createCSSRule(rtlClassNameSelector, rtlCSSDeclaration, selectors);\n  }\n  if (media) {\n    cssRule = `@media ${media} { ${cssRule} }`;\n  }\n  if (layer) {\n    cssRule = `@layer ${layer} { ${cssRule} }`;\n  }\n  if (support) {\n    cssRule = `@supports ${support} { ${cssRule} }`;\n  }\n  if (container) {\n    cssRule = `@container ${container} { ${cssRule} }`;\n  }\n  return compileCSSRules(cssRule, true);\n}\nexport { compileAtomicCSSRule, normalizePseudoSelector };","map":{"version":3,"names":["PSEUDO_SELECTOR_REGEX","normalizePseudoSelector","pseudoSelector","normalizeNestedProperty","replace","createCSSRule","classNameSelector","cssDeclaration","pseudos","cssRule","length","reduceRight","acc","selector","compileAtomicCSSRule","options","className","media","layer","selectors","support","property","rtlClassName","rtlProperty","rtlValue","value","container","Array","isArray","map","v","hyphenateProperty","join","rtlClassNameSelector","rtlCSSDeclaration","compileCSSRules"],"sources":["/Users/gideoncrawley/Projects/Lookeeloo/packages/core/src/runtime/compileAtomicCSSRule.ts"],"sourcesContent":["import { hyphenateProperty } from './utils/hyphenateProperty';\nimport { normalizeNestedProperty } from './utils/normalizeNestedProperty';\nimport { compileCSSRules } from './compileCSSRules';\n\nexport interface CompileAtomicCSSOptions {\n  className: string;\n\n  selectors: string[];\n  media: string;\n  layer: string;\n  support: string;\n  container: string;\n\n  property: string;\n  value: number | string | Array<number | string>;\n\n  rtlClassName?: string;\n  rtlProperty?: string;\n  rtlValue?: number | string | Array<number | string>;\n}\n\nconst PSEUDO_SELECTOR_REGEX = /,( *[^ &])/g;\n\n/**\n * Normalizes pseudo selectors to always contain &, requires to work properly with comma-separated selectors.\n *\n * @example\n *   \":hover\" => \"&:hover\"\n *   \" :hover\" => \"& :hover\"\n *   \":hover,:focus\" => \"&:hover,&:focus\"\n *   \" :hover, :focus\" => \"& :hover,& :focus\"\n */\nexport function normalizePseudoSelector(pseudoSelector: string): string {\n  return (\n    '&' +\n    normalizeNestedProperty(\n      // Regex there replaces a comma, spaces and an ampersand if it's present with comma and an ampersand.\n      // This allows to normalize input, see examples in JSDoc.\n      pseudoSelector.replace(PSEUDO_SELECTOR_REGEX, ',&$1'),\n    )\n  );\n}\n\nfunction createCSSRule(classNameSelector: string, cssDeclaration: string, pseudos: string[]): string {\n  let cssRule = cssDeclaration;\n\n  if (pseudos.length > 0) {\n    cssRule = pseudos.reduceRight((acc, selector) => {\n      return `${normalizePseudoSelector(selector)} { ${acc} }`;\n    }, cssDeclaration);\n  }\n\n  return `${classNameSelector}{${cssRule}}`;\n}\n\nexport function compileAtomicCSSRule(\n  options: CompileAtomicCSSOptions,\n): [string? /* ltr definition */, string? /* rtl definition */] {\n  const {\n    className,\n    media,\n    layer,\n    selectors,\n    support,\n    property,\n    rtlClassName,\n    rtlProperty,\n    rtlValue,\n    value,\n    container,\n  } = options;\n\n  const classNameSelector = `.${className}`;\n  const cssDeclaration = Array.isArray(value)\n    ? `${value.map(v => `${hyphenateProperty(property)}: ${v}`).join(';')};`\n    : `${hyphenateProperty(property)}: ${value};`;\n\n  let cssRule = createCSSRule(classNameSelector, cssDeclaration, selectors);\n\n  if (rtlProperty && rtlClassName) {\n    const rtlClassNameSelector = `.${rtlClassName}`;\n    const rtlCSSDeclaration = Array.isArray(rtlValue)\n      ? `${rtlValue.map(v => `${hyphenateProperty(rtlProperty)}: ${v}`).join(';')};`\n      : `${hyphenateProperty(rtlProperty)}: ${rtlValue};`;\n\n    cssRule += createCSSRule(rtlClassNameSelector, rtlCSSDeclaration, selectors);\n  }\n\n  if (media) {\n    cssRule = `@media ${media} { ${cssRule} }`;\n  }\n\n  if (layer) {\n    cssRule = `@layer ${layer} { ${cssRule} }`;\n  }\n\n  if (support) {\n    cssRule = `@supports ${support} { ${cssRule} }`;\n  }\n\n  if (container) {\n    cssRule = `@container ${container} { ${cssRule} }`;\n  }\n\n  return compileCSSRules(cssRule, true) as [string?, string?];\n}\n"],"mappings":";;;AAqBA,MAAMA,qBAAqB,GAAG,aAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,uBAAuBA,CAACC,cAAsB,EAAU;EACtE,OACE,GAAG,GACHC,uBAAuB;EACrB;EACA;EACAD,cAAc,CAACE,OAAO,CAACJ,qBAAqB,EAAE,MAAM,CACtD,CAAC;AAEL;AAEA,SAASK,aAAaA,CAACC,iBAAyB,EAAEC,cAAsB,EAAEC,OAAiB,EAAU;EACnG,IAAIC,OAAO,GAAGF,cAAc;EAE5B,IAAIC,OAAO,CAACE,MAAM,GAAG,CAAC,EAAE;IACtBD,OAAO,GAAGD,OAAO,CAACG,WAAW,CAAC,CAACC,GAAG,EAAEC,QAAQ,KAAK;MAC/C,OAAQ,GAAEZ,uBAAuB,CAACY,QAAQ,CAAE,MAAKD,GAAO;KACzD,EAAEL,cAAc,CAAC;EACpB;EAEA,OAAU,GAAAD,iBAAqB,IAAAG,OAAU;AAC3C;AAEO,SAASK,oBAAoBA,CAClCC,OAAgC,EAC8B;EAC9D,MAAM;IACJC,SAAS;IACTC,KAAK;IACLC,KAAK;IACLC,SAAS;IACTC,OAAO;IACPC,QAAQ;IACRC,YAAY;IACZC,WAAW;IACXC,QAAQ;IACRC,KAAK;IACLC;EACF,CAAC,GAAGX,OAAO;EAEX,MAAMT,iBAAiB,GAAO,IAAAU,SAAW;EACzC,MAAMT,cAAc,GAAGoB,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,GACtC,GAAEA,KAAK,CAACI,GAAG,CAACC,CAAC,IAAK,GAAEC,iBAAiB,CAACV,QAAQ,CAAE,KAAIS,CAAE,EAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAI,MACrE,GAAED,iBAAiB,CAACV,QAAQ,CAAE,KAAII,KAAQ;EAE/C,IAAIhB,OAAO,GAAGJ,aAAa,CAACC,iBAAiB,EAAEC,cAAc,EAAEY,SAAS,CAAC;EAEzE,IAAII,WAAW,IAAID,YAAY,EAAE;IAC/B,MAAMW,oBAAoB,GAAO,IAAAX,YAAc;IAC/C,MAAMY,iBAAiB,GAAGP,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,GAC5C,GAAEA,QAAQ,CAACK,GAAG,CAACC,CAAC,IAAK,GAAEC,iBAAiB,CAACR,WAAW,CAAE,KAAIO,CAAE,EAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAI,MAC3E,GAAED,iBAAiB,CAACR,WAAW,CAAE,KAAIC,QAAW;IAErDf,OAAO,IAAIJ,aAAa,CAAC4B,oBAAoB,EAAEC,iBAAiB,EAAEf,SAAS,CAAC;EAC9E;EAEA,IAAIF,KAAK,EAAE;IACTR,OAAO,GAAI,UAASQ,KAAM,MAAKR,OAAW;EAC5C;EAEA,IAAIS,KAAK,EAAE;IACTT,OAAO,GAAI,UAASS,KAAM,MAAKT,OAAW;EAC5C;EAEA,IAAIW,OAAO,EAAE;IACXX,OAAO,GAAI,aAAYW,OAAQ,MAAKX,OAAW;EACjD;EAEA,IAAIiB,SAAS,EAAE;IACbjB,OAAO,GAAI,cAAaiB,SAAU,MAAKjB,OAAW;EACpD;EAEA,OAAO0B,eAAe,CAAC1B,OAAO,EAAE,IAAI,CAAC;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}