{"ast":null,"code":"import { DEFINITION_LOOKUP_TABLE } from '../constants.esm.js';\nimport { debugData } from './store.esm.js';\nimport { getDebugClassNames } from './utils.esm.js';\nfunction getDebugTree(debugSequenceHash, parentNode) {\n  const lookupItem = DEFINITION_LOOKUP_TABLE[debugSequenceHash];\n  if (lookupItem === undefined) {\n    return undefined;\n  }\n  const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE[parentNode.sequenceHash] : undefined;\n  const debugClassNames = getDebugClassNames(lookupItem, parentLookupItem, parentNode == null ? void 0 : parentNode.debugClassNames, parentNode == null ? void 0 : parentNode.children);\n  const node = {\n    sequenceHash: debugSequenceHash,\n    direction: lookupItem[1],\n    children: [],\n    debugClassNames\n  };\n  const childrenSequences = debugData.getChildrenSequences(node.sequenceHash);\n  childrenSequences.reverse() // first process the overriding children that are merged last\n  .forEach(sequence => {\n    const child = getDebugTree(sequence, node);\n    if (child) {\n      node.children.push(child);\n    }\n  });\n\n  // if it's leaf (makeStyle node), get css rules\n  if (!node.children.length) {\n    node.rules = {};\n    node.debugClassNames.forEach(({\n      className\n    }) => {\n      const mapData = debugData.getSequenceDetails(debugSequenceHash);\n      if (mapData) {\n        node.slot = mapData.slotName;\n        node.sourceURL = mapData.sourceURL;\n      }\n      const cssRule = debugData.getCSSRules().find(cssRule => {\n        return cssRule.includes(className);\n      });\n      node.rules[className] = cssRule;\n    });\n  }\n  return node;\n}\nexport { getDebugTree };","map":{"version":3,"names":["getDebugTree","debugSequenceHash","parentNode","lookupItem","DEFINITION_LOOKUP_TABLE","undefined","parentLookupItem","sequenceHash","debugClassNames","getDebugClassNames","children","node","direction","childrenSequences","debugData","getChildrenSequences","reverse","forEach","sequence","child","push","length","rules","className","mapData","getSequenceDetails","slot","slotName","sourceURL","cssRule","getCSSRules","find","includes"],"sources":["/Users/gideoncrawley/Projects/Lookeeloo/packages/core/src/devtools/getDebugTree.ts"],"sourcesContent":["import { DEFINITION_LOOKUP_TABLE } from '../constants';\nimport type { LookupItem, SequenceHash } from '../types';\nimport { debugData } from './store';\nimport type { DebugSequence } from './types';\nimport { getDebugClassNames } from './utils';\n\nexport function getDebugTree(debugSequenceHash: SequenceHash, parentNode?: DebugSequence) {\n  const lookupItem: LookupItem | undefined = DEFINITION_LOOKUP_TABLE[debugSequenceHash];\n  if (lookupItem === undefined) {\n    return undefined;\n  }\n\n  const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE[parentNode.sequenceHash] : undefined;\n  const debugClassNames = getDebugClassNames(\n    lookupItem,\n    parentLookupItem,\n    parentNode?.debugClassNames,\n    parentNode?.children,\n  );\n\n  const node: DebugSequence = {\n    sequenceHash: debugSequenceHash,\n    direction: lookupItem[1],\n    children: [],\n    debugClassNames,\n  };\n\n  const childrenSequences = debugData.getChildrenSequences(node.sequenceHash);\n  childrenSequences\n    .reverse() // first process the overriding children that are merged last\n    .forEach((sequence: SequenceHash) => {\n      const child = getDebugTree(sequence, node);\n      if (child) {\n        node.children.push(child);\n      }\n    });\n\n  // if it's leaf (makeStyle node), get css rules\n  if (!node.children.length) {\n    node.rules = {};\n    node.debugClassNames.forEach(({ className }) => {\n      const mapData = debugData.getSequenceDetails(debugSequenceHash);\n      if (mapData) {\n        node.slot = mapData.slotName;\n        node.sourceURL = mapData.sourceURL;\n      }\n\n      const cssRule = debugData.getCSSRules().find(cssRule => {\n        return cssRule.includes(className);\n      });\n\n      node.rules![className] = cssRule!;\n    });\n  }\n\n  return node;\n}\n"],"mappings":";;;AAMO,SAASA,YAAYA,CAACC,iBAA+B,EAAEC,UAA0B,EAAE;EACxF,MAAMC,UAAkC,GAAGC,uBAAuB,CAACH,iBAAiB,CAAC;EACrF,IAAIE,UAAU,KAAKE,SAAS,EAAE;IAC5B,OAAOA,SAAS;EAClB;EAEA,MAAMC,gBAAgB,GAAGJ,UAAU,GAAGE,uBAAuB,CAACF,UAAU,CAACK,YAAY,CAAC,GAAGF,SAAS;EAClG,MAAMG,eAAe,GAAGC,kBAAkB,CACxCN,UAAU,EACVG,gBAAgB,EAChBJ,UAAU,oBAAVA,UAAU,CAAEM,eAAe,EAC3BN,UAAU,oBAAVA,UAAU,CAAEQ,QACd,CAAC;EAED,MAAMC,IAAmB,GAAG;IAC1BJ,YAAY,EAAEN,iBAAiB;IAC/BW,SAAS,EAAET,UAAU,CAAC,CAAC,CAAC;IACxBO,QAAQ,EAAE,EAAE;IACZF;GACD;EAED,MAAMK,iBAAiB,GAAGC,SAAS,CAACC,oBAAoB,CAACJ,IAAI,CAACJ,YAAY,CAAC;EAC3EM,iBAAiB,CACdG,OAAO,EAAE;EAAA,CACTC,OAAO,CAAEC,QAAsB,IAAK;IACnC,MAAMC,KAAK,GAAGnB,YAAY,CAACkB,QAAQ,EAAEP,IAAI,CAAC;IAC1C,IAAIQ,KAAK,EAAE;MACTR,IAAI,CAACD,QAAQ,CAACU,IAAI,CAACD,KAAK,CAAC;IAC3B;EACF,CAAC,CAAC;;EAEJ;EACA,IAAI,CAACR,IAAI,CAACD,QAAQ,CAACW,MAAM,EAAE;IACzBV,IAAI,CAACW,KAAK,GAAG,EAAE;IACfX,IAAI,CAACH,eAAe,CAACS,OAAO,CAAC,CAAC;MAAEM;IAAU,CAAC,KAAK;MAC9C,MAAMC,OAAO,GAAGV,SAAS,CAACW,kBAAkB,CAACxB,iBAAiB,CAAC;MAC/D,IAAIuB,OAAO,EAAE;QACXb,IAAI,CAACe,IAAI,GAAGF,OAAO,CAACG,QAAQ;QAC5BhB,IAAI,CAACiB,SAAS,GAAGJ,OAAO,CAACI,SAAS;MACpC;MAEA,MAAMC,OAAO,GAAGf,SAAS,CAACgB,WAAW,EAAE,CAACC,IAAI,CAACF,OAAO,IAAI;QACtD,OAAOA,OAAO,CAACG,QAAQ,CAACT,SAAS,CAAC;MACpC,CAAC,CAAC;MAEFZ,IAAI,CAACW,KAAK,CAAEC,SAAS,CAAC,GAAGM,OAAQ;IACnC,CAAC,CAAC;EACJ;EAEA,OAAOlB,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}