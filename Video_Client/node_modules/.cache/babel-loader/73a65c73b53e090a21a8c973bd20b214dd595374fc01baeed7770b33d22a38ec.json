{"ast":null,"code":"import { SEQUENCE_PREFIX, RESET_HASH_PREFIX, DEBUG_RESET_CLASSES, SEQUENCE_SIZE, DEFINITION_LOOKUP_TABLE, LOOKUP_DEFINITIONS_INDEX, LOOKUP_DIR_INDEX } from './constants.esm.js';\nimport { hashSequence } from './runtime/utils/hashSequence.esm.js';\nimport { reduceToClassName } from './runtime/reduceToClassNameForSlots.esm.js';\n\n// Contains a mapping of previously resolved sequences of atomic classnames\nconst mergeClassesCachedResults = {};\n\n/**\n * Function can take any number of arguments, joins classes together and deduplicates atomic declarations generated by\n * `makeStyles()`. Handles scoped directional styles.\n *\n * Classnames can be of any length, this function can take both atomic declarations and class names.\n *\n * Input:\n * ```\n * // not real classes\n * mergeClasses('ui-button', 'displayflex', 'displaygrid')\n * ```\n *\n * Output:\n * ```\n * 'ui-button displaygrid'\n * ```\n */\n\nfunction mergeClasses() {\n  // arguments are parsed manually to avoid double loops as TS & Babel transforms rest via an additional loop\n  // @see https://babeljs.io/docs/en/babel-plugin-transform-parameters\n  /* eslint-disable prefer-rest-params */\n\n  let dir = null;\n  let resultClassName = '';\n\n  // Is used as a cache key to avoid object merging\n  let sequenceMatch = '';\n  const sequencesIds = new Array(arguments.length);\n  let containsResetClassName = '';\n  for (let i = 0; i < arguments.length; i++) {\n    const className = arguments[i];\n    if (typeof className === 'string' && className !== '') {\n      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets\n      // without parsing each className in a string\n      const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);\n      if (sequenceIndex === -1) {\n        if (process.env.NODE_ENV !== 'production') {\n          className.split(' ').forEach(entry => {\n            if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) {\n              if (containsResetClassName) {\n                // eslint-disable-next-line no-console\n                console.error('mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (' + `${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:` + 'https://griffel.js.org/react/api/make-reset-styles#limitations' + '\\n' + `Source string: ${className}`);\n              } else {\n                containsResetClassName = entry;\n              }\n            }\n          });\n        }\n        resultClassName += className + ' ';\n      } else {\n        const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);\n\n        // Handles a case with mixed classnames, i.e. \"ui-button ATOMIC_CLASSES\"\n        if (sequenceIndex > 0) {\n          resultClassName += className.slice(0, sequenceIndex);\n        }\n        sequenceMatch += sequenceId;\n        sequencesIds[i] = sequenceId;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {\n          // eslint-disable-next-line no-console\n          console.error('mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start ' + `with \"${SEQUENCE_PREFIX}\"), it's possible that passed classes were concatenated in a wrong way. ` + `Source string: ${className}`);\n        }\n      }\n    }\n  }\n\n  // .slice() there allows to avoid trailing space for non-atomic classes\n  // \"ui-button ui-flex \" => \"ui-button ui-flex\"\n  if (sequenceMatch === '') {\n    return resultClassName.slice(0, -1);\n  }\n\n  // It's safe to reuse results to avoid continuous merging as results are stable\n  // \"__seq1 ... __seq2 ...\" => \"__seq12 ...\"\n  const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];\n  if (mergeClassesResult !== undefined) {\n    return resultClassName + mergeClassesResult;\n  }\n  const sequenceMappings = [];\n  for (let i = 0; i < arguments.length; i++) {\n    const sequenceId = sequencesIds[i];\n    if (sequenceId) {\n      const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];\n      if (sequenceMapping) {\n        sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);\n        if (process.env.NODE_ENV !== 'production') {\n          if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {\n            // eslint-disable-next-line no-console\n            console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction ` + `(dir=\"${sequenceMapping[1] ? 'rtl' : 'ltr'}\") setting than other classes. This is not supported. ` + `Source string: ${arguments[i]}`);\n          }\n        }\n        dir = sequenceMapping[LOOKUP_DIR_INDEX];\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry ` + `in cache. Source string: ${arguments[i]}`);\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line prefer-spread\n  const resultDefinitions = Object.assign.apply(Object,\n  // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later\n  [{}].concat(sequenceMappings));\n  let atomicClassNames = reduceToClassName(resultDefinitions, dir);\n\n  // Each merge of classes generates a new sequence of atomic classes that needs to be registered\n  const newSequenceHash = hashSequence(atomicClassNames, dir, sequencesIds);\n  atomicClassNames = newSequenceHash + ' ' + atomicClassNames;\n  mergeClassesCachedResults[sequenceMatch] = atomicClassNames;\n  DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultDefinitions, dir];\n  return resultClassName + atomicClassNames;\n}\nexport { mergeClasses, mergeClassesCachedResults };","map":{"version":3,"names":["mergeClassesCachedResults","mergeClasses","dir","resultClassName","sequenceMatch","sequencesIds","Array","arguments","length","containsResetClassName","i","className","sequenceIndex","indexOf","SEQUENCE_PREFIX","process","env","NODE_ENV","split","forEach","entry","startsWith","RESET_HASH_PREFIX","DEBUG_RESET_CLASSES","console","error","sequenceId","substr","SEQUENCE_SIZE","slice","mergeClassesResult","undefined","sequenceMappings","sequenceMapping","DEFINITION_LOOKUP_TABLE","push","LOOKUP_DEFINITIONS_INDEX","LOOKUP_DIR_INDEX","resultDefinitions","Object","assign","apply","concat","atomicClassNames","reduceToClassName","newSequenceHash","hashSequence"],"sources":["/Users/gideoncrawley/Projects/Lookeeloo/packages/core/src/mergeClasses.ts"],"sourcesContent":["import {\n  DEBUG_RESET_CLASSES,\n  DEFINITION_LOOKUP_TABLE,\n  LOOKUP_DEFINITIONS_INDEX,\n  LOOKUP_DIR_INDEX,\n  RESET_HASH_PREFIX,\n  SEQUENCE_PREFIX,\n  SEQUENCE_SIZE,\n} from './constants';\nimport { hashSequence } from './runtime/utils/hashSequence';\nimport { reduceToClassName } from './runtime/reduceToClassNameForSlots';\nimport type { CSSClassesMap, SequenceHash } from './types';\n\n// Contains a mapping of previously resolved sequences of atomic classnames\nexport const mergeClassesCachedResults: Record<string, string> = {};\n\n/**\n * Function can take any number of arguments, joins classes together and deduplicates atomic declarations generated by\n * `makeStyles()`. Handles scoped directional styles.\n *\n * Classnames can be of any length, this function can take both atomic declarations and class names.\n *\n * Input:\n * ```\n * // not real classes\n * mergeClasses('ui-button', 'displayflex', 'displaygrid')\n * ```\n *\n * Output:\n * ```\n * 'ui-button displaygrid'\n * ```\n */\nexport function mergeClasses(...classNames: (string | false | undefined)[]): string;\n\nexport function mergeClasses(): string {\n  // arguments are parsed manually to avoid double loops as TS & Babel transforms rest via an additional loop\n  // @see https://babeljs.io/docs/en/babel-plugin-transform-parameters\n  /* eslint-disable prefer-rest-params */\n\n  let dir: 'ltr' | 'rtl' | null = null;\n  let resultClassName = '';\n\n  // Is used as a cache key to avoid object merging\n  let sequenceMatch = '';\n  const sequencesIds: (SequenceHash | undefined)[] = new Array(arguments.length);\n\n  let containsResetClassName = '';\n\n  for (let i = 0; i < arguments.length; i++) {\n    const className = arguments[i];\n\n    if (typeof className === 'string' && className !== '') {\n      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets\n      // without parsing each className in a string\n      const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);\n\n      if (sequenceIndex === -1) {\n        if (process.env.NODE_ENV !== 'production') {\n          className.split(' ').forEach(entry => {\n            if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) {\n              if (containsResetClassName) {\n                // eslint-disable-next-line no-console\n                console.error(\n                  'mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (' +\n                    `${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:` +\n                    'https://griffel.js.org/react/api/make-reset-styles#limitations' +\n                    '\\n' +\n                    `Source string: ${className}`,\n                );\n              } else {\n                containsResetClassName = entry;\n              }\n            }\n          });\n        }\n\n        resultClassName += className + ' ';\n      } else {\n        const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);\n\n        // Handles a case with mixed classnames, i.e. \"ui-button ATOMIC_CLASSES\"\n        if (sequenceIndex > 0) {\n          resultClassName += className.slice(0, sequenceIndex);\n        }\n\n        sequenceMatch += sequenceId;\n        sequencesIds[i] = sequenceId;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {\n          // eslint-disable-next-line no-console\n          console.error(\n            'mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start ' +\n              `with \"${SEQUENCE_PREFIX}\"), it's possible that passed classes were concatenated in a wrong way. ` +\n              `Source string: ${className}`,\n          );\n        }\n      }\n    }\n  }\n\n  // .slice() there allows to avoid trailing space for non-atomic classes\n  // \"ui-button ui-flex \" => \"ui-button ui-flex\"\n  if (sequenceMatch === '') {\n    return resultClassName.slice(0, -1);\n  }\n\n  // It's safe to reuse results to avoid continuous merging as results are stable\n  // \"__seq1 ... __seq2 ...\" => \"__seq12 ...\"\n  const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];\n\n  if (mergeClassesResult !== undefined) {\n    return resultClassName + mergeClassesResult;\n  }\n\n  const sequenceMappings: CSSClassesMap[] = [];\n\n  for (let i = 0; i < arguments.length; i++) {\n    const sequenceId = sequencesIds[i];\n\n    if (sequenceId) {\n      const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];\n\n      if (sequenceMapping) {\n        sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {\n            // eslint-disable-next-line no-console\n            console.error(\n              `mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction ` +\n                `(dir=\"${sequenceMapping[1] ? 'rtl' : 'ltr'}\") setting than other classes. This is not supported. ` +\n                `Source string: ${arguments[i]}`,\n            );\n          }\n        }\n\n        dir = sequenceMapping[LOOKUP_DIR_INDEX];\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.error(\n            `mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry ` +\n              `in cache. Source string: ${arguments[i]}`,\n          );\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line prefer-spread\n  const resultDefinitions = Object.assign.apply<ObjectConstructor, CSSClassesMap[], CSSClassesMap>(\n    Object,\n    // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later\n    [{}].concat(sequenceMappings),\n  );\n\n  let atomicClassNames = reduceToClassName(resultDefinitions, dir!);\n\n  // Each merge of classes generates a new sequence of atomic classes that needs to be registered\n  const newSequenceHash = hashSequence(atomicClassNames, dir!, sequencesIds);\n  atomicClassNames = newSequenceHash + ' ' + atomicClassNames;\n\n  mergeClassesCachedResults[sequenceMatch] = atomicClassNames;\n  DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultDefinitions, dir!];\n\n  return resultClassName + atomicClassNames;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}